//Citation Import for Zotero (modified MOD export) to Indesign CS6 or later//(c) 2013 Kai Kasugaiapp.scriptPreferences.version = 8; //Indesign CS6 and later. Use 7.5 to use CS5.5 features//$.level = 2;//global varsvar myDocument, myXML;//styles, tags, layervar parsedReferenceStyle, parsedReferenceTag, noReferenceStyle;var referenceParagraphStyle, referenceParagraphStyleHead;var styleAuthor, styleYear, styleTitle;var hoverObjectLayer; //the layer for hover objectsvar hoverObjectStyle; //the style for hover objects (the hidden ones)var hoverTriggerStyle; //the style for the objects (rectangles) that mask the text and trigger the hover objectvar hoverTextframeStyle; //the style for the textframe that contains the bibliography info//text frame with bibliographyvar myRefTextFrame;//arraysvar myCitekeyInfo = new CiteKeyInfo();//error arraysvar error_publishtypes = new Array();var error_general = new Array();var notice_general = new Array();var foundNew = 0;var foundTotal = 0;var removedOld = 0;//settingsvar showStatistics, showWarnings;var createHoveringReferences;var defaultDirectory = false;var useDefaultDirectory = false;var bibliographyName = "Bibliographie";var xmlSettingsTag = 'zoteroImportSettings';//Locate and run the glue code.jsx file.var myFilePath = app.filePath + "/Scripts/xml rules/glue code.jsx";if(File(myFilePath).exists == false){    myFilePath = File.openDialog("Locate the file: glue code.jsx");}if(myFilePath != null){    var myFile = File(myFilePath); app.doScript(myFile);    main();} else {    alert('unable to locate glue code.jsc');}function main(){    myDocument = app.documents.item(0);    //define styles and tag vars    parsedReferenceStyle = returnCharacterStyleOrCreatenew("parsedReference");    noReferenceStyle = myDocument.characterStyles[0]; //[0] should always be equal to [None], but as the name for [none] is internationalised, we cannot use myDocument.characterStyles.item("[None]"),  but have to use the first object in the document character styles array    styleAuthor = returnCharacterStyleOrCreatenew("REF-Autor");    styleYear = returnCharacterStyleOrCreatenew("REF-Jahr");    styleTitle = returnCharacterStyleOrCreatenew("REF-Titel");    referenceParagraphStyle = returnParagraphStyleOrCreatenew("Referenzen", null, {        leftIndent: 6,        firstLineIndent: -6,        spaceAfter: 3,        pointSize:10,        appliedFont: "Minion Pro",        fontStyle: "Regular"    });    referenceParagraphStyleHead = returnParagraphStyleOrCreatenew("Level 1","Level");    referenceHoverParagraphStyle = returnParagraphStyleOrCreatenew("Referenzen Hover", null, {        basedOn: referenceParagraphStyle,        firstLineIndent: 0,        leftIndent: 0    });    hoverObjectLayer = returnLayerOrCreatenew("Hover Objects");    hoverTriggerStyle = returnObjectStyleOrCreatenew("Hover Object Trigger (hidden)",{        enableFill: true,        fillColor: myDocument.swatches[0],//~         objectEffectsEnablingSettings: {//~             enableTransparency: true },//~         transparencySettings: {//~             blendingSettings: {//~                 blendMode: BlendMode.MULTIPLY, opacity: 30}},        enableStroke: true,        strokeColor: myDocument.swatches[0],        enableTextWrapAndOthers: true,        textWrapPreferences: {            textWrapMode: TextWrapModes.NONE}    });    hoverTextframeStyle = returnObjectStyleOrCreatenew("Hover Textframe",{        enableFill: true,        fillColor: myDocument.swatches[2],        fillTint: 100,        objectEffectsEnablingSettings: {            enableTransparency: false },        enableStroke: true,        strokeColor: myDocument.swatches[3],        strokeWeight: .1,        enableTextWrapAndOthers: true,        textWrapPreferences: {            textWrapMode: TextWrapModes.NONE},        enableTextFrameGeneralOptions: true,        enableTextFrameAutoSizingOptions: true,        textFramePreferences :{            textColumnCount: 1,            autoSizingType: AutoSizingTypeEnum.HEIGHT_ONLY,            autoSizingReferencePoint: AutoSizingReferenceEnum.TOP_CENTER_POINT,            insetSpacing:4}            });    //set tag or create new    try{        parsedReferenceTag = myDocument.xmlTags.item('referencetag');        name = parsedReferenceTag.name;    } catch(e) {        parsedReferenceTag = myDocument.xmlTags.add('referencetag');    }            //ask for options    if (!userSettingsDialog()){        return false;    }            //import XML file    if (!myImportXMLFileUsingDefaults()) {        return false;    }    //show unknown genres so that we can improve the script when a new genre comes up    if (error_publishtypes.length > 0){        alert("Following genres where unknown:\n" + error_publishtypes);    }    //show errors    if (error_general.length > 0){        alert("There where following errors:\n" + error_general.join("\n"));    }    //show warnings (if activated)    if (notice_general.length > 0 && showWarnings){        alert("There where following warnings:\n" + notice_general.join("\n"));    }}//asks for a xml file and imports it using set defaultsfunction myImportXMLFileUsingDefaults(){	//xml file pre-read    var myXMLFile;    if (useDefaultDirectory){        myXMLFile = new File(defaultDirectory);    }    else {        myXMLFile = File.openDialog("Please select the Zotero XML file", "*.xml");        if (myXMLFile == null) {            alert('You cancelled. Aborting script.');            return false;        }        //write default directory setting        checkOrWriteSetting("defaultDirectory",myXMLFile);    }    if (!myXMLFile.exists){        checkOrWriteSetting("defaultDirectory","");        alert('error reading file');        exit();    }    myXMLFile.open('r');    var myXMLStr = myXMLFile.read(); //read XML file into variable    myXMLFile.close(); //close XML file    var root = new XML(myXMLStr); //convert variable into XML object    var xc = root.xpath("//mods");    if (xc.length() < 1){        checkOrWriteSetting("defaultDirectory","");        alert("no valid Items found in file");        return false;    }    //$.writeln('Number of references in XML found: ' + xc .length());        //USING FIND    // Clear the find/change grep preferences    app.findGrepPreferences = NothingEnum.NOTHING;    app.changeGrepPreferences = NothingEnum.NOTHING;    // Set the find options    app.findChangeGrepOptions.includeFootnotes = false;    app.findChangeGrepOptions.includeHiddenLayers = false;    app.findChangeGrepOptions.includeLockedLayersForFind = false;    app.findChangeGrepOptions.includeLockedStoriesForFind = false;    app.findChangeGrepOptions.includeMasterPages = false;    app.findGrepPreferences.findWhat = '\\\\cite[rayt]?\\{[^{}]*\\}';    var myFindings = myDocument.findGrep();    // Clear the find/change grep preferences again    app.findGrepPreferences = NothingEnum.NOTHING;    app.changeGrepPreferences = NothingEnum.NOTHING;    for (var i = myFindings.length - 1; i >= 0; i--){        var myRawCitekey = myFindings[i].texts[0];        var myCitekeyMatchArray = myRawCitekey.contents.match(/\\(cite[rayt]?)\{([^{}]*)\}/);        var myCiteType = myCitekeyMatchArray[1];        var myCitekey = myCitekeyMatchArray[2];        //continue and alert if no proper citekey was found (shouldnt ever happen, because this is part of a grep find with exactyly the same regex)        if (!myCitekey || myCitekey == ''){            error_general.push("Error when parsing citekey " + myRawCitekey.contents);            continue;        }                //create xml element and add attributes        var myNewXMLElement;        try{            //first create a new xml element in the associated xml element            myNewXMLElement = myRawCitekey.associatedXMLElements[0].xmlElements.add(parsedReferenceTag);        } catch(e){            myDocument.xmlElements[0].xmlElements.add('storyelement',myRawCitekey.parentStory);            myNewXMLElement = myRawCitekey.associatedXMLElements[0].xmlElements.add(parsedReferenceTag);        }        //apply an attribute        myNewXMLElement.xmlAttributes.add('citekey',myCitekey.replace(/^\s+|\s+$/g, '')); //safe attribute using trimming        //add attribute describing the citekey type        switch(myCiteType){            case 'citea':                myNewXMLElement.xmlAttributes.add('citetype','authorOnly');                break;            case 'citey':                myNewXMLElement.xmlAttributes.add('citetype','yearOnly');                break;            case 'cite':                myNewXMLElement.xmlAttributes.add('citetype','default');                break;            case 'citer':                myNewXMLElement.xmlAttributes.add('citetype','noBrackets');                break;            case 'citet':                myNewXMLElement.xmlAttributes.add('citetype','titleOnly');                break;            default:                //to extend, add the new cite command and make sure that you add it to the 2 regular expressions (find settings and also in this for loop)                myNewXMLElement.xmlAttributes.add('citetype','unknown type');                error_general.push("cannot determine cite type for" + myCitekey);                break;        }                //link the xmlelment (which was, until now, at the end of the structure) to the text (the xml element then moves to the right point in the structure, according to the occurence of the text)        myRawCitekey.markup(myNewXMLElement);        foundNew++;    }    myXML= myDocument.xmlElements[0];    var allReferenceTags = myXML.evaluateXPathExpression("//referencetag");    //now, all new citekeys have been tagged. we can parse the document xml and collect unique citekeys. go backwards, because we want to delete empty elements    for (var r = allReferenceTags.length - 1; r >=0 ; r--){        //see if the element content was empty and delete the tag and the item in the array if so        if (allReferenceTags[r].contents.replace(/^\s+|\s+$/g, '') == ''){            allReferenceTags[r].remove(); //removes the tag            allReferenceTags.splice(r,1); //removes the item in the array            removedOld++;            continue;        }        //add citetype attribute if not already done (for compatibility reasons with older documents)        try{            allReferenceTags[r].xmlAttributes.itemByName('citetype').value;        }        catch(e) {            notice_general.push(allReferenceTags[r].xmlAttributes.item('citekey').value + ' did not have citetype attribute. adding default attribute.');            allReferenceTags[r].xmlAttributes.add('citetype','default');        }        //store citekey in an array to be sorted and processed later        myCitekeyInfo.getKey(allReferenceTags[r].xmlAttributes.item('citekey').value);        foundTotal++;    }    //sort references in bibliography by citekey    myCitekeyInfo.sortKeys();    //CLEAN UP    //delete existing hyperlink sources (text anchors within the xmlelement.content)    if (myDocument.hyperlinkTextSources.length > 0){        for(var i = myDocument.hyperlinkTextSources.length -1; i >= 0; i--){            //do not remove the contents of the comment around the OR condition. this might be needed to clean older files, that did not use labels but used names starting with ZotRefSrc (as they do now, but regex match is slow...)            if (myDocument.hyperlinkTextSources[i].label == 'zotrefLinksrc' /*|| myDocument.hyperlinkTextSources[i].name.match(/ZotRefSrc[0-9]+/i)*/){                //$.writeln("deleted source: " + allHyperlinkSources[i].name + ", label: " + allHyperlinkSources[i].label);                myDocument.hyperlinkTextSources[i].remove();            }        }    }    //delete all hyperlink destinations    if (myDocument.hyperlinkTextDestinations.length > 0){        for (var i = myDocument.hyperlinkTextDestinations.length - 1; i >= 0; i--){            if (myDocument.hyperlinkTextDestinations[i].label == 'zotrefLinkDest') {                myDocument.hyperlinkTextDestinations[i].remove();            }        }    }    //delete all hyperlinks (seems to be unnecessary as hyperlinks (src - dest)) are automatically deleted when the hyperlink source is deleted)    //hyperlink destinations need not to be deleted as they are deleted with the emptying of the reference frame    if (myDocument.hyperlinks.length > 0){        for (var i = myDocument.hyperlinks.length - 1; i >= 0; i--){            if (myDocument.hyperlinks[i].label == 'zotrefHyperlink'){                myDocument.hyperlinks[i].remove();            }        }    }    //remove all old hover rectangles TODO: remove. now buttons!    for(var i = myDocument.rectangles.length - 1; i >= 0; i--){        if (myDocument.rectangles.item(i).label == 'zotRefHoverTrigger'){            myDocument.rectangles.item(i).remove();        }    }    //remove all old hover textframes TODO: remove. now buttons!    for(var i = myDocument.textFrames.length - 1; i >=0; i--){        if (myDocument.textFrames.item(i).label == 'zotRefHoverTextframe'){            myDocument.textFrames.item(i).remove();        }    }    //remove all old hover and trigger buttons    for(var i = myDocument.buttons.length - 1; i >=0; i--){        if (myDocument.buttons.item(i).label == 'zotRefHoverButton' || myDocument.buttons.item(i).label == 'zotRefTriggerButton'){            myDocument.buttons.item(i).remove();        }    }    //CREATE REFERENCE TEXT FRAME    //find reference text frame    for (var i = 0; i < myDocument.pages.count(); i++){        for (var j = 0; j < myDocument.pages[i].textFrames.count(); j++){            if (myDocument.pages[i].textFrames[j].label == 'references'){                myRefTextFrame = myDocument.pages[i].textFrames[j];                myRefTextFrame.parentStory.contents = "";                addFormattedTextToStory(myRefTextFrame,false,(bibliographyName == '' ? " " : bibliographyName),referenceParagraphStyleHead);            }        }    }    //create new page with textframe for references if none was found    if (!myRefTextFrame){        var newPage = myDocument.pages.add();        myRefTextFrame = newPage.textFrames.add();        myRefTextFrame.label = 'references';        myRefTextFrame.geometricBounds = [newPage.marginPreferences.top,newPage.bounds[1] + newPage.marginPreferences.left,newPage.bounds[2] - newPage.marginPreferences.bottom,newPage.bounds[3] - newPage.marginPreferences.right];        myRefTextFrame.contents = "References";        notice_general.push("Page " + (newPage.documentOffset+1) + " was created with the textframe for the references. If you want to define your own reference textframe, please create a textframe with the script-label \"references\". This textframe (and the parent story) will be emptied and filled with references.");    }    //search for citekey in the xml file and add to the references textframe    findings:    for(var i = 0; i < myCitekeyInfo.citeKeyArray.length; i++){        xmlcontents:        for(var c = 0; c < xc .length(); c++){            if (xc[c].citeKey == myCitekeyInfo.citeKeyArray[i].citeKey){                myCitekeyInfo.citeKeyArray[i].found = true;                addFormattedTextToStory(myRefTextFrame,false, "\r",false);                myCitekeyInfo.citeKeyArray[i].hyperlinkTextDestination = myDocument.hyperlinkTextDestinations.add(myRefTextFrame.parentStory.insertionPoints[-1],{name:"ref-" + xc[c].citeKey, label: 'zotrefLinkDest'}); //create a hyperlink text destination and safe it in the meta data of the citation                addFormattedTextToStory(myRefTextFrame,styleAuthor, getAuthorNames(xc[c]),referenceParagraphStyle);                addFormattedTextToStory(myRefTextFrame,styleTitle,  getTitle(xc[c]));                addFormattedTextToStory(myRefTextFrame,styleTitle,  getPublishedIn(xc[c]));                addFormattedTextToStory(myRefTextFrame,styleYear,   getYearAndPublisher(xc[c]));                //safe link to entire paragraph in metadata                myCitekeyInfo.citeKeyArray[i].bibParagraph = myRefTextFrame.parentStory.insertionPoints[-2].index; //use -2, to not get the last insertionpoint, which moves as new content is added                continue findings;            }        }        error_general.push("CITEKEY NOT FOUND: " + myCitekeyInfo.citeKeyArray[i].citeKey);    }    //now, all citekeys where searched and all citekeys in the text have a tag. we can parse the tags and replace the contents by the reference. alternatively, we could make a text search    //for all the citekeys and replace one citekey at a time - maybe better performace, but this would make updating impossible!    var buttonNumber = 0;    for (var r = 0; r < allReferenceTags.length; r++){        var currentKey = allReferenceTags[r].xmlAttributes.item('citekey').value;        //write NOT FOUND tag into reference keys that where not found in the parsed xml file. parse a file where they exist and the text will be replaced by the valid reference info        if (myCitekeyInfo.getItemByKey(currentKey).found == false){            allReferenceTags[r].contents = "[??NOTFOUND??]";            continue;        }                switch(allReferenceTags[r].xmlAttributes.item('citetype').value){            case 'default':                allReferenceTags[r].contents = "[" + myCitekeyInfo.getReference(currentKey) + "]";                allReferenceTags[r].applyCharacterStyle(parsedReferenceStyle);                break;            case 'noBrackets':                allReferenceTags[r].contents = myCitekeyInfo.getReference(currentKey);                allReferenceTags[r].applyCharacterStyle(parsedReferenceStyle);                break;            case 'authorOnly':                allReferenceTags[r].contents = myCitekeyInfo.getItemByKey(currentKey).author;                allReferenceTags[r].applyCharacterStyle(noReferenceStyle);                break;            case 'yearOnly':                allReferenceTags[r].contents = myCitekeyInfo.getItemByKey(currentKey).year.toString();                allReferenceTags[r].applyCharacterStyle(noReferenceStyle);                break;            case 'titleOnly':                allReferenceTags[r].contents = myCitekeyInfo.getItemByKey(currentKey).title.toString();                allReferenceTags[r].applyCharacterStyle(noReferenceStyle);                break;        }        //add hyperlinks        var myReferenceTagText = allReferenceTags[r].characters.itemByRange(allReferenceTags[r].insertionPoints.firstItem(),allReferenceTags[r].insertionPoints.lastItem());        //if the following line causes an error, maybe there are old textsources in the document. remove them by removing the comment tags around allHyperlinkSources[i].name.match(/ZotRefSrc[0-9]+/i)        var myReferenceSource = myDocument.hyperlinkTextSources.add(myReferenceTagText,{name:"ZotRefSrc" + r, label: "zotrefLinksrc"});        myDocument.hyperlinks.add(myReferenceSource,myCitekeyInfo.getItemByKey(currentKey).hyperlinkTextDestination,{name: r + "_" + currentKey,label:"zotrefHyperlink"});                //add hover effects        //create new        if (createHoveringReferences == true){            switch(allReferenceTags[r].xmlAttributes.item('citetype').value){                case 'default':                case 'noBrackets':                    createReferenceButton(allReferenceTags[r], myCitekeyInfo.getItemByKey(allReferenceTags[r].xmlAttributes.item('citekey').value).bibParagraph, buttonNumber);                    buttonNumber++;                    break;            }        }    }    if (showStatistics){        alert("Done\nNew citations: " + foundNew + "\nExisting citations: " + (foundTotal - foundNew) + "\nRemoved existing: " + removedOld + "\nNumber of unique references: " + myCitekeyInfo.citeKeyArray.length);    }        return true;}function createReferenceButton(referenceTextXMLElement, bibliographyParagraphLastInsertionPoint, buttonNumber){    var refPage;    var theReferenceText = referenceTextXMLElement.texts[0];    var currentKey = referenceTextXMLElement.xmlAttributes.item('citekey').value; //TODO: maybe cache this?    var hoverElementDistance = 2; //distance to text    var maskOffset = 1; //how much bigger than the text    var hoverWidth = 70; //width of the hovering element    //first, create all maskrectangles and collect them in an array    var maskRectangles = Array();    if (theReferenceText.lines.length == 1){        refPage = referenceTextXMLElement.insertionPoints.firstItem().parentTextFrames[0].parentPage;        var ry1 = theReferenceText.insertionPoints.item(0).baseline + maskOffset;        var ry2 = theReferenceText.insertionPoints.item(0).baseline - theReferenceText.texts[0].ascent - maskOffset;        var rx1 = theReferenceText.insertionPoints.item(0).horizontalOffset - maskOffset;        var rx2 = theReferenceText.insertionPoints.item(-1).endHorizontalOffset + maskOffset;        maskRectangles.push(refPage.rectangles.add({geometricBounds:[ry1,rx1,ry2,rx2], label: "zotRefHoverTrigger",itemLayer: hoverObjectLayer, appliedObjectStyle: hoverTriggerStyle}));    } else {        for(var l = 0; l < theReferenceText.lines.length; l++){            var currentLine = theReferenceText.lines.item(l);            refPage = currentLine.parentTextFrames[0].parentPage;            var ry1 = currentLine.baseline + maskOffset;            var ry2 = currentLine.baseline - currentLine.ascent - maskOffset;            var rx1 = currentLine.horizontalOffset - maskOffset;            var rx2 = currentLine.endHorizontalOffset + maskOffset;                        //exception first line:            if (l == 0){                rx1 = theReferenceText.insertionPoints.item(0).horizontalOffset - maskOffset;            }            //exception last line            else if (l == theReferenceText.lines.length - 1) {                rx2 = theReferenceText.insertionPoints.item(-1).endHorizontalOffset + maskOffset;            }        maskRectangles.push(refPage.rectangles.add({geometricBounds:[ry1,rx1,ry2,rx2], label: "zotRefHoverTrigger",itemLayer: hoverObjectLayer, appliedObjectStyle: hoverTriggerStyle}));        }    }    //then, create the tooltip geometry    var firstRectPage = maskRectangles[0].parentPage;    var hovergBounds = [maskRectangles[0].geometricBounds[2] + hoverElementDistance - maskOffset,maskRectangles[0].geometricBounds[1] + maskOffset, maskRectangles[0].geometricBounds[2] + 5 + hoverElementDistance - maskOffset, maskRectangles[0].geometricBounds[1] + hoverWidth];    var hoverTextframe = firstRectPage.textFrames.add({itemLayer: hoverObjectLayer, geometricBounds: hovergBounds, label: 'zotRefHoverTextframe', appliedObjectStyle: hoverTextframeStyle});    //duplicate the reference paragraph into the text frame    myRefTextFrame.insertionPoints[bibliographyParagraphLastInsertionPoint].paragraphs[0].duplicate(LocationOptions.AT_BEGINNING,hoverTextframe.insertionPoints.firstItem()).appliedParagraphStyle = referenceHoverParagraphStyle;    hoverTextframe.characters[-1].remove(); //removing the linebreak at the end of the paragraph        //create the hover button    var hoverButton = firstRectPage.buttons.add({itemLayer: hoverObjectLayer, geometricBounds: hovergBounds, label: 'zotRefHoverButton'});    hoverButton.states.item(0).addItemsToState(hoverTextframe);    hoverButton.hiddenUntilTriggered = true;    hoverButton.name = 'zotRefHover' + buttonNumber + "_" + referenceTextXMLElement.xmlAttributes.item('citekey').value;    hoverButton.bringToFront();        //now that the hovering text is created, we can trigger the tooltip with our line masks    for (var i = 0; i < maskRectangles.length; i++){        var currentLineRect = maskRectangles[i];        var triggerButton = firstRectPage.buttons.add({itemLayer: hoverObjectLayer, geometricBounds: currentLineRect.geometricBounds, label: 'zotRefTriggerButton'});        triggerButton.states.item(0).addItemsToState(currentLineRect);        triggerButton.name = 'zotRefTrigger' + buttonNumber + "." + i + "_" + referenceTextXMLElement.xmlAttributes.item('citekey').value;        triggerButton.showHideFieldsBehaviors.add({behaviorEvent:BehaviorEvents.MOUSE_ENTER, fieldsToShow: hoverButton});        triggerButton.showHideFieldsBehaviors.add({behaviorEvent:BehaviorEvents.MOUSE_EXIT, fieldsToHide: hoverButton});        triggerButton.showHideFieldsBehaviors.add({behaviorEvent:BehaviorEvents.MOUSE_DOWN, fieldsToHide: hoverButton}); //necessary, because otherwise the hover will stay visible when clicked (page jumps to reference and no MOUSE_EXIT is triggered)        triggerButton.gotoAnchorBehaviors.add({behaviorEvent:BehaviorEvents.MOUSE_UP, anchorItem: myCitekeyInfo.getItemByKey(currentKey).hyperlinkTextDestination});        triggerButton.sendToBack();    }        //then check, if the element is within the page bounds. if not, move (top, if y is out, left, if the rightmost point is of of x)    //then draw a polygon around the text        //convert the newly created textbox to a button. set hide until triggered preference. this will be the tooltip    //convert the previously created rectangle(s) to a button. this button will trigger the revelation of the tooltips    //reveal the textbox button upon hover over rectangle(s).    //maybe, reveal the trigger button can reveal itself.    //$.bp();}function addFormattedTextToStory(myTextframe,myFormat,myContent,myParagraphFormat){    if (!myContent) return false;    //safe insertion point index    var firstInsertionPoint = myTextframe.parentStory.insertionPoints[-1].index;    //add text    myTextframe.parentStory.insertionPoints[-1].contents += myContent;    var myAdditions = myTextframe.parentStory.characters.itemByRange(myTextframe.parentStory.insertionPoints[firstInsertionPoint],myTextframe.parentStory.insertionPoints[-1]);    //add formatting    if (myFormat) {        myAdditions.appliedCharacterStyle = myFormat;    }    if (myParagraphFormat) {        myAdditions.appliedParagraphStyle = myParagraphFormat;    }    return true;}function getPublishedIn(modPart){    //return if book (books are not published in anything    var genre = modPart.xpath("genre[@authority='local']");    if (genre.toString() == 'book' || genre.toString() == 'thesis') {        if (modPart.xpath("relatedItem[@type='host']/titleInfo[not(@type = 'abbreviated')]/title") != '') {            notice_general.push(modPart.citeKey + ' seems to have a related published medium, but the genre is ' + genre.toString() + '. please check this item');        }        return false;    }        var publishedIn = modPart.xpath("relatedItem[@type='host']/titleInfo[not(@type = 'abbreviated')]/title");    if (!publishedIn || publishedIn.toString() == "") {        //genres that do not necessarily need a published medium        if (genre.toString() == 'report'){            return false;        }        notice_general.push("could not find the published medium for " + modPart.citeKey);        return false;    }    switch(modPart.xpath("relatedItem[@type='host']/genre[@authority='marcgt']").toString()) {        case 'book':        case 'conference publication':            publishedIn = ", in " + publishedIn;            break;        default:            publishedIn = ", " + publishedIn;            break;    }        return publishedIn;}function getAuthorNames(modPart,depth){    //how often did this function call itself    if (depth == null){        depth = 0;    }    //find names    var names = modPart.xpath("name[@type='personal' or @type='corporate']");    if (names.length() < 1) {        //go deeper if this is the initial call         if (depth == 0){             return getAuthorNames(modPart.xpath("relatedItem[@type='host']"),1);         }        error_general.push("no names found for " + modPart.citeKey);        return "---NO NAMES---";    }        var nameConcat = "";    var nameArray = new Array();    var editorArray = new Array();    var firstAuthorName;        //parse names    for(var n = 0; n < names.length(); n++){        var role = names[n].xpath("role/roleTerm").toString().replace(/^\s+|\s+$/g, '');        if (role == 'aut' || role == 'edt' || role == 'ctb') {            var thisName;            var lastName = names[n].xpath("namePart[@type='family']");            var firstName = names[n].xpath("namePart[@type='given']").toString().substr(0,1) + ".";            if (!lastName || lastName == '') {                thisName = names[n].xpath("namePart[not(@type)]'"); //take namepart that does not have any attributes, if given and family name where not specified                //safe the first name for references in the text                if (!firstAuthorName || firstAuthorName == ''){                    firstAuthorName = thisName;                }                if (!thisName){                    continue;                }            }            else {                if (!firstAuthorName || firstAuthorName == ''){                    firstAuthorName = lastName;                }                thisName = lastName + (firstName ? ", " + firstName : "");            }                    if (role == 'aut' || role == 'ctb'){                nameArray.push(thisName);            } else {                editorArray.push(thisName);            }        }    }    //check if any names    if (nameArray.length < 1){        //if also no editors        if (editorArray.length < 1){            error_general.push("no names parsed for " + modPart.citeKey);            //safe citekey Info            myCitekeyInfo.safeAuthors(modPart.citeKey,'unknown');            return "---NO NAMES (2)---";        }        //if editors        else {            //connect editors            for (var n = 0; n < editorArray.length; n++){                nameConcat += (n > 0 && n != editorArray.length-1 ? ", " : (n == editorArray.length-1  && editorArray.length != 1 ? " and " : "")) + editorArray[n];            }            //safe citekey Info            myCitekeyInfo.safeAuthors(modPart.citeKey,(firstAuthorName ? firstAuthorName : 'error1')+ (editorArray.length > 1 ? " et al." : ""));            return nameConcat + ", Eds.";        }    }    //connect authors    for (var n = 0; n < nameArray.length; n++){        nameConcat += (n > 0 && n != nameArray.length-1 ? ", " : (n == nameArray.length-1 && nameArray.length != 1 ? " and " : "")) + nameArray[n];    }    //safe citekey Info    myCitekeyInfo.safeAuthors(modPart.citeKey,(firstAuthorName ? firstAuthorName : 'error1') + (nameArray.length > 1 ? " et al." : ""));    return nameConcat;    }/*Object that stores the cite key meta data */function CiteKeyMeta(citeKey){    this.author = "";    this.year = "";    this.title = "";    this.citeKey = citeKey;    this.found = false;    this.hyperlinkTextDestination;    this.bibParagraph;}/* Class to story citekey array and receive and output metadatainfo. also to query the citekey array */function CiteKeyInfo(){    this.citeKeyArray = new Array();        this.safeAuthors = function(ck, author) {        var currentC = this.getKey(ck);        this.citeKeyArray[currentC].author = author.toString();        return true;    }    this.safeYear = function(ck, year) {        var currentC = this.getKey(ck);        this.citeKeyArray[currentC].year = year.toString().match(/[0-9]{4}/);        return true;    }    this.safeTitle = function(ck, title) {        var currentC = this.getKey(ck);        this.citeKeyArray[currentC].title = title.toString();        return true;    }    this.getReference = function(ck) {        var currentC = this.getKey(ck, false);        if (currentC === false){            return "[error3 in " + ck + "]";        }        return this.citeKeyArray[currentC].author + ", " + this.citeKeyArray[currentC].year;    }    this.sortKeys = function(){        //sort key        var tempArray = new Array();        var tempArrayObjects = new Array();        for (var i in this.citeKeyArray){            //$.writeln('pushing ' + i + ": " + this.citeKeyArray[i].citeKey);            tempArray.push(this.citeKeyArray[i].citeKey);        }        tempArray.sort();        //reconstruct        for(var i in tempArray){            //$.writeln('pushing ' + i + ": " + tempArray[i]);            tempArrayObjects.push(this.citeKeyArray[this.getKey(tempArray[i],false)]);        }            //overwrite old array with temp array        this.citeKeyArray = tempArrayObjects;                return true;    }        //returns one item out of the citekeyarray. does not create a new item if not found    this.getItemByKey = function(ck){        var currentItemKey = this.getKey(ck, false);        //return false if the item was not found        if (currentItemKey === false){            return false;        }            return (this.citeKeyArray[currentItemKey]);    }        //returns the index of the item or creates one if the item did not exist    this.getKey = function(ck, createNew) {        //see if a new key should be created. true by default        if (createNew == undefined){            createNew = true;        }        for(var c = 0; c < this.citeKeyArray.length; c++){            if (this.citeKeyArray[c].citeKey == ck.toString()){                return c;            }        }        //should a new key be created if none was found?        if (createNew) {            this.citeKeyArray.push(new CiteKeyMeta(ck.toString()));            return this.citeKeyArray.length - 1;        }        else {            return false;        }    }}function getYearAndPublisher(modPart){    var genre = modPart.xpath("genre[@authority='local']");    var year;    var publisher;    var place;        switch (genre.toString()){        case "bookSection":            year = modPart.xpath("relatedItem[@type='host']/originInfo/copyrightDate");            publisher = modPart.xpath("relatedItem[@type='host']/originInfo/publisher");            place = modPart.xpath("relatedItem[@type='host']/originInfo/place/placeTerm[@type='text']");            break;        case "book":            year = modPart.xpath("originInfo/copyrightDate");            publisher = modPart.xpath("originInfo/publisher");            place = modPart.xpath("originInfo/place/placeTerm[@type='text']");            break;        case "conferencePaper":        case "encyclopediaArticle":            year = modPart.xpath("relatedItem[@type='host']/originInfo/dateCreated");            publisher = modPart.xpath("relatedItem[@type='host']/originInfo/publisher");            place = modPart.xpath("relatedItem[@type='host']/originInfo/place/placeTerm[@type='text']");            break;        case "blogPost":        case "webpage":            year = modPart.xpath("relatedItem[@type='host']/originInfo/dateCreated");            if (year == ''){                year = modPart.xpath("location/url/attribute::dateLastAccessed");                if (year != ''){                    year = year.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})*/);                    year = "online as of " + returnMonthName(year[2]) + " " + year[1];                }            }            break;        case "magazineArticle":        case "journalArticle":        case "newspaperArticle":            year = modPart.xpath("relatedItem[@type='host']/originInfo/dateIssued");            publisher = modPart.xpath("relatedItem[@type='host']/originInfo/publisher");            place = modPart.xpath("relatedItem[@type='host']/originInfo/place/placeTerm[@type='text']");            break;        case "thesis":        case "report":        case "artwork":        case "presentation":        case "patent":        case "manuscript":        case "videoRecording":        case "interview":        case "document":            year = modPart.xpath("originInfo/dateCreated");            publisher = modPart.xpath("originInfo/publisher");            place = modPart.xpath("originInfo/place/placeTerm[@type='text']");            break;        default:            if (!findObjInArray(error_publishtypes,genre.toString())){                error_publishtypes.push(genre.toString());            }            return false;    }        if (!year || year == ''){        error_general.push("could not identify year for " + modPart.citeKey + " (genre: " + genre.toString() + ")");        return false;    }    //safe citekeyinfo    myCitekeyInfo.safeYear(modPart.citeKey,year);    return (publisher && publisher != '' ? ", " + publisher + (place && place != '' ? ", " + place : "") : "") + ", " + year;}function getTitle(modPart){    var title = modPart.xpath("titleInfo[not(@type = 'abbreviated')]/title").toString();    if (!title) {        error_general.push("could not identify title for " + modPart.citeKey);        return false;    } else {        //safe title in citekeyinfo and return        myCitekeyInfo.safeTitle(modPart.citeKey,title);        return ", \"" + title + "\"";    }}//searches for an object in an array. expects the array and the object (string, integer, object etc)function findObjInArray(a,obj){    for (var i = 0; i < a.length; i++) {        if (a[i] === obj) {            return true;        }    }    return false;    }//return the reference to a character style. if the style did not exist, create the stylefunction returnCharacterStyleOrCreatenew(stylename){    style = myDocument.characterStyles.item(stylename);    try{        name=style.name;    } catch(e) {        style = myDocument.characterStyles.add({name: stylename});        style.name = stylename;    }    return style;}//return the reference to a paragraph style. if the style did not exist, create the stylefunction returnParagraphStyleOrCreatenew(stylename, groupname, stylePreferences){    var style;    if (!groupname){ //is the style in a group?        style = myDocument.paragraphStyles.item(stylename);    } else {        var group;        try { //add group first, if it does not exist            group = myDocument.paragraphStyleGroups.itemByName(groupname);            gname = group.name; //will trigger error if group does not exist        }        catch(e){            group = myDocument.paragraphStyleGroups.add({name: groupname});            style = group.paragraphStyles.add({name: stylename}); //then add style in the group        }        style = group.paragraphStyles.itemByName(stylename); //select style in group (for the second time, if the style had already been created, but that should be ok)    }    try{        name=style.name; //will trigger error if style does not exist    } catch(e) {        if (stylePreferences != null){            stylePreferences.name = stylename;            style = myDocument.paragraphStyles.add(stylePreferences);        } else {                        style = myDocument.paragraphStyles.add({name: stylename});        }    }    return style;}function returnLayerOrCreatenew(layerName){    var layer;    layer = myDocument.layers.item(layerName);    try{        name = layer.name;    } catch(e) {        layer = myDocument.layers.add({name: layerName});    }    return layer;}//return an existing object style or create a new object style. if preferences are given, these will be applied to the new object style only.function returnObjectStyleOrCreatenew(objectStyleName, newObjectStylePreferences){    var objectStyle;    objectStyle = myDocument.objectStyles.item(objectStyleName);    try{        name = objectStyle.name;    } catch(e) {        if (newObjectStylePreferences != null) {            newObjectStylePreferences.name = objectStyleName;            objectStyle = myDocument.objectStyles.add(newObjectStylePreferences);        } else {            objectStyle = myDocument.objectStyles.add({name: objectStyleName});        }    }    return objectStyle;}//to ask for user settings in the beginningfunction userSettingsDialog(){    var myDialog = app.dialogs.add({name:"Zotero to Indesign Interface settings"});    var useDefaultCheckbox;    //Add a dialog column.    with(myDialog.dialogColumns.add()){        if (checkOrWriteSetting("defaultDirectory")) {            with(borderPanels.add()){                with(dialogColumns.add()){                    useDefaultCheckbox = checkboxControls.add({checkedState: true, staticLabel: "Use last XML file"});                }            }        }            with(borderPanels.add()){            with(dialogColumns.add()){                staticTexts.add({staticLabel:"Title for references page(s):"});            }            with(dialogColumns.add()){                var bibliographyNameSetting = textEditboxes.add({editContents: (checkOrWriteSetting("bibliographyName") ? checkOrWriteSetting("bibliographyName") : bibliographyName), minWidth: 180});            }        }            with(borderPanels.add()){            staticTexts.add({staticLabel:"Messages"});            var showStatisticsSetting = checkboxControls.add({checkedState: (checkOrWriteSetting("showStatistics") == 'yes' ? true : (checkOrWriteSetting("showStatistics") == 'no' ? false : true)), staticLabel: "show statistics"});            var showWarningsSetting = checkboxControls.add({checkedState: (checkOrWriteSetting("showWarnings") == 'yes' ? true : (checkOrWriteSetting("showWarnings") == 'no' ? false : true)), staticLabel: "show warnings"});        }        with(borderPanels.add()){            with(dialogColumns.add()){                var createHoveringReferencesSetting = checkboxControls.add({checkedState: (checkOrWriteSetting("createHoveringReferences") == 'yes' ? true : (checkOrWriteSetting("createHoveringReferences") == 'no' ? false : false)), staticLabel: "Interactive reference tooltips"});            }        }    }    //Show the dialog box.    var myResult = myDialog.show();    if(myResult == true){        if (useDefaultCheckbox && useDefaultCheckbox.checkedState) {            defaultDirectory = checkOrWriteSetting("defaultDirectory");            useDefaultDirectory = true;        }        bibliographyName = bibliographyNameSetting.editContents;        checkOrWriteSetting("bibliographyName",bibliographyName);                showStatistics = showStatisticsSetting.checkedState;        checkOrWriteSetting("showStatistics",(showStatistics == true ? "yes" : "no"));        showWarnings = showWarningsSetting.checkedState;        checkOrWriteSetting("showWarnings",(showWarnings == true ? "yes" : "no"));        createHoveringReferences = createHoveringReferencesSetting.checkedState;        checkOrWriteSetting("createHoveringReferences",(createHoveringReferences == true ? "yes" : "no"));        myDialog.destroy();        return true;    }    else{        alert("Aborting");        myDialog.destroy();        return false;    }}//to store user settings in documentfunction checkOrWriteSetting(settingName, newSetting){    //check for settings root first    var mySettingsRoot = myDocument.xmlElements[0].xmlElements.itemByName(xmlSettingsTag)    if (!mySettingsRoot || !mySettingsRoot.isValid){        if (newSetting == null) {            return false;        }        mySettingsRoot = myDocument.xmlElements[0].xmlElements.add(xmlSettingsTag);        mySettingsRoot = mySettingsRoot.move(LocationOptions.atBeginning)    }            //check for the attribute defaultDirectory    var defDir  = mySettingsRoot.xmlAttributes.itemByName(settingName);    //if there is no default directory set    if (!defDir.isValid){        //if no default directory was set        if (newSetting == null){            return false;        }        //create new attribute or write to attribute        mySettingsRoot.xmlAttributes.add(settingName,newSetting);    }    //if the value exists, but is empty    else if (newSetting != null || defDir.value.toString() == ''){        if (newSetting == null){            return false;        }        mySettingsRoot.xmlAttributes.itemByName(settingName).value = newSetting;            }    //attribute exists, is not empty, return the attributes value    else {        return defDir.value;    }}//month number to english month stringfunction returnMonthName(monthInt){    switch (parseInt(monthInt,10)){        case 1:            return "January";            break;        case 2:            return "February";            break;        case 3:            return "March";            break;        case 4:            return "April";            break;        case 5:            return "May";            break;        case 6:            return "June";            break;        case 7:            return "July";            break;        case 8:            return "August";            break;        case 9:            return "September";            break;        case 10:            return "October";            break;        case 11:            return "November";            break;        case 12:            return "December";            break;        default:            return false;    }}